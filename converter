#!/usr/bin/env python

import argparse
import logging
import json
import os
from pydub import AudioSegment


LOG = logging.getLogger(__name__)


def parse_cli():
    """
    Parses command line options.
    @return Parsed options
    """

    parser = argparse.ArgumentParser(
            description='File converter for VOCALOID OpenTX voice banks')

    parser.add_argument(
        '--log-level',
        action='store',
        default='INFO',
        help='Logging level [DEBUG,INFO,WARNING,ERROR,CRITICAL]'
    )

    parser.add_argument(
        '-s', '--sound-file',
        action='append',
        type=str,
        help='Input sound definition file'
    )

    parser.add_argument(
        '-o', '--output',
        action='append',
        type=str,
        help='Output configuration file'
    )

    props = parser.parse_args()

    log_level = getattr(logging, props.log_level.upper(), None)
    if not isinstance(log_level, int):
        log_level = logging.INFO

    logging.basicConfig(level=log_level,
                        format='%(levelname)s: %(message)s')

    return props


def read_json_file(filename):
    """
    Reads a JSON input/output configuration file.
    @param filename Path to file to read
    @return Tuple (file base name, data)
    """

    LOG.info('Reading JSON file %s', filename)
    with open(filename, 'r') as ifp:
        data = json.load(ifp)

    name = os.path.splitext(os.path.basename(filename))[0]
    return (name, data)


def make_json_paths_absolute(data, json_file):
    """
    Converts the paths in a sound config file to absolute paths.
    @param data JSON data
    @param json_file Path to JSON file
    """

    json_directory = os.path.abspath(os.path.dirname(json_file))
    data['vsq_file'] = os.path.join(json_directory, data['vsq_file'])
    data['audio_file'] = os.path.join(json_directory, data['audio_file'])


def get_soundfile_config(sound_name, sound_files):
    """
    Searches for a retrieves the sound config for a given sound.
    @param sound_name Name of the sound to find
    @param sound_files All sound files to search through
    @return Tuple (sound position, timing info, audio filename)
    """

    LOG.debug('Looking for sound %s', sound_name)
    for f_name, f_data in sound_files.items():
        LOG.debug('Searching in sound config %s', f_name)
        for s_name, s_data in f_data['sounds'].items():
            if s_name == sound_name:
                return (s_data, f_data['timing'], f_data['audio_file'])


def process_target(target_config, sound_files):
    """
    Processes audio files for a given target.
    @param target_config Configuration for the target
    @param sound_files Configurations for all sound files
    """

    LOG.info('Processing target %s', target_config['profile'])

    out_directory = os.path.abspath(target_config['directory'])
    if not os.path.exists(out_directory):
        os.makedirs(out_directory)
    LOG.info('Output directory: %s', out_directory)

    for filename, sound_name in target_config['sounds'].items():
        LOG.debug('Processing sound %s', sound_name)
        sound_config = get_soundfile_config(sound_name, sound_files)
        if sound_config is None:
            LOG.warn('Cannot find sound %s', sound_name)
            continue
        out_filename = os.path.join(out_directory, filename)
        slice_audio(sound_config, target_config['audio_format'], out_filename)


def slice_audio(sound_config, audio_config, filename):
    """
    Calculates he timing for a sound file, slices it and saves the result.
    @param sound_config Configuration data for sound clip
    @param audio_config Configuration for the audio output
    @param filename Filename of the output audio file
    """

    LOG.debug('Processing audio for %s', filename)
    sound = AudioSegment.from_wav(sound_config[2])

    ms_per_beat = 60000 / sound_config[1]['beats_per_minute']
    ms_per_measure = ms_per_beat * sound_config[1]['beats_per_measure']
    start = ms_per_measure * sound_config[0]['start_measure']
    end = start + (sound_config[0]['beat_duration'] * ms_per_beat)

    LOG.debug('Calculates start and end times %d-%d', start, end)

    sound_segment = sound[start:end]

    sound_segment += audio_config['gain']
    sound_segment.set_channels(audio_config['channels'])
    sound_segment.set_frame_rate(audio_config['sample_freq'])
    sound_segment.export(filename, format='wav')


if __name__ == '__main__':
    props = parse_cli();

    # Read sound files
    sound_files = {}
    for f in props.sound_file:
        name, data = read_json_file(f)
        make_json_paths_absolute(data, f)
        sound_files[name] = data

    # Read and process targets
    for f in props.output:
        data = read_json_file(f)[1]
        process_target(data, sound_files)

