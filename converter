#!/usr/bin/env python

import argparse
import logging
import json
import os
import xmltodict
from pydub import AudioSegment


LOG = logging.getLogger(__name__)


def parse_cli():
    """
    Parses command line options.
    @return Parsed options
    """

    parser = argparse.ArgumentParser(
            description='File converter for VOCALOID OpenTX voice banks')

    parser.add_argument(
        '--log-level',
        action='store',
        default='INFO',
        help='Logging level [DEBUG,INFO,WARNING,ERROR,CRITICAL]'
    )

    parser.add_argument(
        '-s', '--sound-file',
        action='append',
        type=str,
        help='Input sound definition file'
    )

    parser.add_argument(
        '-o', '--output',
        action='append',
        type=str,
        help='Output configuration file'
    )

    props = parser.parse_args()

    log_level = getattr(logging, props.log_level.upper(), None)
    if not isinstance(log_level, int):
        log_level = logging.INFO

    logging.basicConfig(level=log_level,
                        format='%(levelname)s: %(message)s')

    return props


def read_json_file(filename):
    """
    Reads a JSON input/output configuration file.
    @param filename Path to file to read
    @return Tuple (file base name, data)
    """

    LOG.info('Reading JSON file %s', filename)
    with open(filename, 'r') as ifp:
        data = json.load(ifp)

    name = os.path.splitext(os.path.basename(filename))[0]
    return (name, data)


def make_json_paths_absolute(data, json_file):
    """
    Converts the paths in a sound config file to absolute paths.
    @param data JSON data
    @param json_file Path to JSON file
    """

    json_directory = os.path.abspath(os.path.dirname(json_file))
    data['vsq_file'] = os.path.join(json_directory, data['vsq_file'])
    data['audio_file'] = os.path.join(json_directory, data['audio_file'])


def read_vsq_file(data):
    """
    Reads the VSQ(X) file and stores it along with the JSON.
    @param data JSON data
    """

    LOG.info('Reading VSQ file %s', data['vsq_file'])
    with open(data['vsq_file'], 'r') as ifp:
        vsq_data = xmltodict.parse(ifp)

    data['vsq_master_track'] = vsq_data['vsq4']['masterTrack']
    data['vsq_voice_track'] = vsq_data['vsq4']['vsTrack']


def get_soundfile_config(sound_name, sound_files):
    """
    Searches for a retrieves the sound config for a given sound.
    @param sound_name Name of the sound to find
    @param sound_files All sound files to search through
    @return Tuple (VSQ part, VSQ master track, audio filename)
    """

    for f_name, f_data in sound_files.items():
        for part_data in f_data['vsq_voice_track']['vsPart']:
            name = part_data['name']

            if name == sound_name:
                return (part_data, f_data['vsq_master_track'], f_data['audio_file'])


def process_target(target_config, sound_files):
    """
    Processes audio files for a given target.
    @param target_config Configuration for the target
    @param sound_files Configurations for all sound files
    """

    LOG.info('Processing target %s', target_config['profile'])

    out_directory = os.path.abspath(target_config['directory'])
    if not os.path.exists(out_directory):
        os.makedirs(out_directory)
    LOG.info('Output directory: %s', out_directory)

    for filename, sound_name in target_config['sounds'].items():
        LOG.debug('Processing sound %s', sound_name)
        sound_config = get_soundfile_config(sound_name, sound_files)
        if sound_config is None:
            LOG.warn('Cannot find sound %s', sound_name)
            continue
        out_filename = os.path.join(out_directory, filename)
        slice_audio(sound_config, target_config['audio_format'], out_filename)


def calculate_time(master_track, vocal_part):
    """
    @param master_track
    @param vocal_part
    """

    bpm = int(master_track['tempo'][-1]['v']) / 100.0
    bpq = int(master_track['resolution'])
    ms_per_tick = 60000.0 / (bpm * bpq)
    LOG.debug('Milliseconds per MIDI tick %f', ms_per_tick)

    start_ticks = int(vocal_part['t'])
    end_ticks = start_ticks + int(vocal_part['playTime'])

    start_time_ms = ms_per_tick * start_ticks
    end_time_ms = ms_per_tick * end_ticks

    LOG.info('Computed time: %f - %f', start_time_ms, end_time_ms)

    return (start_time_ms, end_time_ms)


def slice_audio(sound_config, audio_config, filename):
    """
    Calculates he timing for a sound file, slices it and saves the result.
    @param sound_config Configuration data for sound clip
    @param audio_config Configuration for the audio output
    @param filename Filename of the output audio file
    """

    LOG.info('Processing audio for %s', filename)

    start, end = calculate_time(sound_config[1], sound_config[0])

    sound = AudioSegment.from_wav(sound_config[2])
    sound_segment = sound[start:end]

    sound_segment += audio_config['gain']
    sound_segment.set_channels(audio_config['channels'])
    sound_segment.set_frame_rate(audio_config['sample_freq'])
    sound_segment.export(filename, format='wav')


if __name__ == '__main__':
    props = parse_cli();

    # Read sound files
    sound_files = {}
    for f in props.sound_file:
        name, data = read_json_file(f)
        make_json_paths_absolute(data, f)
        read_vsq_file(data)
        sound_files[name] = data

    # Read and process targets
    for f in props.output:
        data = read_json_file(f)[1]
        process_target(data, sound_files)

